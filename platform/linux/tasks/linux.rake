#------------------------------------------------------------------------
# (The MIT License)
#
# Copyright (c) 2008-2020 Tau Technologies, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# http://rhomobile.com
#------------------------------------------------------------------------
require 'erb'
require 'stringio'
require 'logger'

ALTGTK_CORE_LIB_TARGETS = [
  ['rubylib', 'librubylib.a'],
  ['rholib', 'librholib.a'],
  ['sqlite3', 'libsqlite3.a'],
  ['syncengine', 'libsyncengine.a'],
  ['curl', 'libcurl.a'],
  ['extensions', 'libcoreapi.a']
]

ALTGTK_EXTENSION_LIB_TARGETS = {
  'rhoconnect-client' => ['extensions', 'librhoconnect-client.a']
}

def altgtk_detect_qtdir
  qtdir = ENV['QTDIR']
  return qtdir unless qtdir.nil? || qtdir.strip.empty?

  candidates = []
  candidates << ENV['QMAKE'] if ENV['QMAKE'] && !ENV['QMAKE'].strip.empty?
  candidates += %w[qmake6 qmake-qt6 qmake-qt5 qmake]

  candidates.each do |candidate|
    begin
      path = Jake.run4("which #{candidate}").strip
    rescue
      next
    end

    next if path.nil? || path.empty?

    begin
      prefix = Jake.run4("#{path} -query QT_INSTALL_PREFIX").strip
    rescue
      prefix = File.expand_path('..', File.expand_path('..', path))
    end

    next if prefix.nil? || prefix.strip.empty?

    ENV['QTDIR'] = prefix
    return prefix
  end

  nil
end

def altgtk_core_lib_paths
  ALTGTK_CORE_LIB_TARGETS.map do |folder, file|
    File.join($startdir, 'platform', 'linux', 'bin', folder, file)
  end
end

def altgtk_extension_lib_paths
  return [] unless defined?($app_extensions_list) && $app_extensions_list

  $app_extensions_list.keys.map do |ext|
    target = ALTGTK_EXTENSION_LIB_TARGETS[ext]
    next unless target
    folder, file = target
    File.join($startdir, 'platform', 'linux', 'bin', folder, file)
  end.compact
end

def altgtk_requested_extensions
  return [] unless defined?($app_extensions_list) && $app_extensions_list

  $app_extensions_list.keys.map(&:to_s)
end

def altgtk_regenerate_metadata
  require $startdir + "/lib/rhodes.rb"

  appname   = $appname || 'Rhodes'
  vendor    = $vendor || 'Tau Technologies'
  version   = $version_app || '1.0'
  sdk_ver   = Rhodes::VERSION

  to_macro  = lambda do |value|
    value.to_s.gsub('"', '\\"')
  end

  vendor_slug = vendor.downcase.gsub(/[^0-9a-z]+/, ' ').strip.gsub(/\s+/, '.').gsub(/\.+/, '.')
  vendor_slug = vendor_slug.gsub(/[^0-9a-z\.]/, '')
  vendor_slug = 'rho' if vendor_slug.nil? || vendor_slug.empty?

  app_slug = appname.downcase.gsub(/[^0-9a-z]+/, '')
  app_slug = 'app' if app_slug.nil? || app_slug.empty?

  app_id = "com.#{vendor_slug}.#{app_slug}"

  header = StringIO.new
  header.puts "// Auto-generated by config:altLinux. Do not edit manually."
  header.puts "#pragma once"
  header.puts "#define ALTGTK_APP_NAME \"#{to_macro.call(appname)}\""
  header.puts "#define ALTGTK_APP_VERSION \"#{to_macro.call(version)}\""
  header.puts "#define ALTGTK_VENDOR \"#{to_macro.call(vendor)}\""
  header.puts "#define ALTGTK_APP_ID \"#{to_macro.call(app_id)}\""
  header.puts "#define ALTGTK_SDK_VERSION \"#{to_macro.call(sdk_ver)}\""

  header_path = File.join($startdir, 'platform', 'altMobile', 'gtk', 'src', 'generated_app_info.h')
  Jake.modify_file_if_content_changed(header_path, header)
end

def altgtk_resolve_runtime_deps
  webkit_pkg = 'webkit2gtk-4.1'
  begin
    if Jake.run3_dont_fail('pkg-config --exists webkitgtk-6.0')
      webkit_pkg = 'webkitgtk-6.0'
    elsif Jake.run3_dont_fail('pkg-config --exists webkit2gtk-4.1')
      webkit_pkg = 'webkit2gtk-4.1'
    end
  rescue
    webkit_pkg = 'webkit2gtk-4.1'
  end

  base = [
    "pkgconfig(gtk4)",
    "pkgconfig(libadwaita-1)",
    "pkgconfig(#{webkit_pkg})",
    "gmp",
    "libstdc++"
  ]
  extra = ENV['ALTGTK_EXTRA_DEPS']
  if extra && !extra.strip.empty?
    extra.split(',').map(&:strip).reject(&:empty?).each { |dep| base << dep }
  end
  $deps = base.uniq
end

def altgtk_ensure_core_libs
  puts "[AltGtk] altgtk_ensure_core_libs extensions=#{$app_extensions_list.inspect}"
  libs = altgtk_core_lib_paths + altgtk_extension_lib_paths
  force = ENV['ALTGTK_REBUILD_LIBS'] && !ENV['ALTGTK_REBUILD_LIBS'].strip.empty?
  missing = libs.any? { |p| !File.exist?(p) }
  puts "[AltGtk] altgtk_ensure_core_libs force=#{force} missing=#{missing} libs=#{libs}"

  return if !force && !missing

  qtdir = altgtk_detect_qtdir
  puts "[AltGtk] altgtk_ensure_core_libs QTDIR=#{qtdir.inspect}"
  if qtdir && !qtdir.strip.empty?
    task = Rake::Task['build:altMobile:rhodeslibs']
    task.reenable
    task.invoke
    remaining = libs.select { |p| !File.exist?(p) }
    unless remaining.empty?
      fail <<~MSG
        [AltGtk] build:altMobile:rhodeslibs finished, но не найдены библиотеки:
          #{remaining.join("\n          ")}
        Проверьте лог вызова build:altMobile:rhodeslibs и наличие qmake/make.
      MSG
    end
  else
    fail <<~MSG
      QTDIR is not set and Qt/qmake could not be detected automatically.
      To build altMobile runner with extensions (e.g. rhoconnect-client), set QTDIR to a valid Qt installation or provide QMAKE.
    MSG
  end
end

namespace "config" do
	task :set_current_platform_linux do
		$current_platform = "linux"
	end

	task :linux => ["config:set_current_platform_linux", "switch_app", "config:qt", "config:sys_recognize"] do
		$rubypath = "platform/linux/target/compiler/rubylinux" #path to RubyLixux
		$bindir = $app_path + "/bin"
		$srcdir =  $bindir + "/RhoBundle"
		$excludelib = ['**/builtinME.rb','**/ServeME.rb','**/TestServe.rb']

		$appname = $app_config["name"].nil? ? "Rhodes" : $app_config["name"]
		$appname = $appname.gsub(/[^0-9a-zA-Z\-\+\.]/,'')
		$vendor = $app_config['vendor']
		$vendor = "Tau Technologies" if $vendor.nil?
		$rhobundledir =  $app_path + "/RhoBundle"
		$log_file = $app_config["applog"].nil? ? "applog.txt" : $app_config["applog"]
		$buildcfg = $app_config["buildcfg"] unless $buildcfg
		$buildcfg = "Release" unless $buildcfg
		$detoolappflag = $js_application == true ? "js" : "ruby"
		$tmpdir = File.join($bindir, "tmp")
		$qt_project_dir = File.join( $startdir, 'platform/shared/qt/' )

		$homedir = `echo ~`.to_s.strip
		$current_platform = "linux"
		$qmake_makespec = "linux-g++"
		Rake::Task["config:common"].invoke()

		$connf_build = "Release"
		if !$app_config.nil? && !$app_config["linux"].nil?
			puts "Target configuration: " + $connf_build
		else
			puts "Linux section is not found!"
		end

		if !$app_config["version"].nil?
			$version_app = $app_config["version"]
		else
			$version_app = "1.0"
		end

		$excludelib = ['**/builtinME.rb', '**/ServeME.rb', '**/dateME.rb', '**/rationalME.rb']
		$rho_path =  File.join($app_path, "data", "rho")
		$project_path = File.join($app_path, "project", "qt")
		$app_project_path = File.join($project_path, $appname.downcase)

		$target_path = File.join($app_path, "bin", "target", "linux")
		mkdir_p $target_path
	end

	task :sys_recognize do
		$architecture = Jake.run("uname", ["-m"])
		name_out = Jake.run('hostnamectl', [])
		if name_out.downcase().include? "ubuntu"
			$ubuntu = true
			puts "Current system is Ubuntu"
		elsif name_out.downcase().include? "astra"
			$astra = true
			puts "Current system is Astra Linux"
		elsif name_out.downcase().include? ":alt:"
			$altlinux = true
			puts "Current system is Alt Linux"
		elsif name_out.downcase().include? ":redos:"
			$redos = true
			puts "Current system is Red OS Linux"
			$qmake_addition_args = '"LIBS += -L/usr/lib64/libglvnd/ -lGL"'
		elsif name_out.downcase().include? ":rosa:"
			$rosalinux = true
			puts "Current system is Rosa Linux"
		else
			puts "Fail! Current system has not been recognized while cunfiguration."
			exit 1
		end
	end


	namespace "linux" do
		task :application do
			$app_version = '1.0'
			$app_version = $app_config["version"] unless $app_config["version"].nil?

			require $startdir + "/lib/rhodes.rb"
			fversion = StringIO.new("", "w+")
			fversion.write( "#define RHOSIMULATOR_NAME \"RhoSimulator\"\n" )
			fversion.write( "#define RHOSIMULATOR_VERSION \"#{Rhodes::VERSION}\"\n" )
			fversion.write( "#define APPLICATION_NAME \"#{$appname}\"\n" )
			fversion.write( "#define APPLICATION_VERSION \"#{$app_version}\"\n" )
			Jake.modify_file_if_content_changed( File.join($startdir, 'platform/shared/qt/rhodes/RhoSimulatorVersion.h'), fversion )

			$app_icon_path = $app_path + "/icon/icon.ico"
			$app_icon_path = $startdir + "/res/icons/rhodes.ico" unless File.exist? $app_icon_path
			cp $app_icon_path, $startdir + "/platform/shared/qt/rhodes/resources/rho.ico"

			$qt_icon_path = $app_path + "/icon/icon.png"
			$qt_icon_path = $startdir + "/res/icons/rhodes.png" unless File.exist? $qt_icon_path
			cp $qt_icon_path, $startdir + "/platform/shared/qt/rhodes/resources/rho.png"
			qrcfile = $startdir + "/platform/shared/qt/rhodes/GeneratedFiles/" + $buildcfg + "/qrc_simulator.cpp"
			rm qrcfile if File.exist? qrcfile
		end
	end
end

namespace "build" do
	namespace "linux" do
		task :rhobundle => ["config:linux", "build:bundle:noxruby"] do
			if !$skip_build_extensions
				Rake::Task["build:linux:extensions"].execute
			end
			Jake.build_file_map( File.join($srcdir, "apps"), "rhofilelist.txt" )
		end

		task :appbundle => ["config:linux", "build:bundle:noxruby"] do
			Jake.build_file_map( File.join($srcdir, "apps"), "rhofilelist.txt" )
		end

		task :extensions => "config:linux" do
			require $startdir + "/lib/rhodes.rb"
			fversion = StringIO.new("", "w+")
			fversion.write( "#define RHOSIMULATOR_NAME \"RhoSimulator\"\n" )
			fversion.write( "#define RHOSIMULATOR_VERSION \"#{Rhodes::VERSION}\"\n" )
			fversion.write( "#define APPLICATION_NAME \"#{$appname}\"\n" )
			fversion.write( "#define APPLICATION_VERSION \"#{$app_version}\"\n" )
			Jake.modify_file_if_content_changed( File.join($startdir, 'platform/shared/qt/rhodes/RhoSimulatorVersion.h'), fversion )

			extensions_lib = ''

			puts "$app_extensions_list : #{$app_extensions_list}"

			$app_extensions_list.each do |ext, commin_ext_path |
				puts "extension #{ext} [#{commin_ext_path}]"
				next unless commin_ext_path

				extpath = File.join(commin_ext_path, 'ext')
				ext_config_path = File.join(commin_ext_path, "ext.yml")
				ext_config = nil
				if File.exist? ext_config_path
					ext_config = Jake.config(File.open(ext_config_path))
				end

				project_path = ext_config["project_paths"][$current_platform] if ( ext_config && ext_config["project_paths"] && ext_config["project_paths"][$current_platform])
				next unless (File.exist?( File.join(extpath, "build") ) || project_path)

				if (ext != 'openssl.so')
					extensions_lib << "LIBS += -L$$PWD/../../../linux/bin/extensions/ -l#{ext.downcase}\n"
					extensions_lib << "PRE_TARGETDEPS += $$PWD/../../../linux/bin/extensions/lib#{ext.downcase}.a\n\n"
				end

				if (project_path)

					ENV['RHO_PLATFORM'] = 'linux'
					ENV['PWD'] = $startdir
					ENV['RHO_ROOT'] = $startdir
					ENV['RHO_VSPROJ_SDK_PLATFORM'] = $sdk
					if ext.downcase() == "coreapi" && $rhosimulator_build
							ENV['RHO_BUILD_CONFIG'] = 'SimulatorRelease'
					else
							ENV['RHO_BUILD_CONFIG'] = $rhosimulator_build ? 'Release' : $buildcfg
							ENV['TARGET_EXT_DIR_SIM'] = File.join($startdir, "platform", 'linux', "bin", $sdk, "rhodes", $rhosimulator_build ? "SimulatorRelease" : $buildcfg)
					end

					ENV['TEMP_FILES_DIR'] = File.join($startdir, "platform", "linux", "bin", "extensions", ext)
					ENV['RHO_PROJECT_PATH'] = File.join(commin_ext_path, project_path)
					ENV['TARGET_TEMP_DIR'] = File.join($startdir, "platform", "linux", "bin", "extensions")

					ENV['RHO_EXT_NAME']=ext
					Jake.run3('rake --trace', File.join($startdir, 'lib/build/extensions'))
				else
					ENV['RHO_PLATFORM'] = 'linux'
					ENV['RHO_BUILD_CONFIG'] = $rhosimulator_build ? 'Release' : $buildcfg
					ENV['PWD'] = $startdir
					ENV['RHO_ROOT'] = ENV['PWD']
					ENV['TARGET_TEMP_DIR'] = File.join(ENV['PWD'], "platform", "linux", "bin", "extensions")
					ENV['TEMP_FILES_DIR'] = File.join(ENV['PWD'], "platform", "linux", "bin", "extensions", ext)
					ENV['RHO_VSPROJ_SDK_PLATFORM'] = $sdk
					ENV['RHO_QMAKE'] = $qmake
					ENV['RHO_QMAKE_VARS'] = $rhosimulator_build ? 'RHOSIMULATOR_BUILD=1' : ""
					ENV['RHO_QMAKE_SPEC'] = $qmake_makespec
					ENV['RHO_VSCMNTOOLS'] = $vscommontools

					if($debug and !$rhosimulator_build)
						ENV['RHO_QMAKE_VARS'] = ENV['RHO_QMAKE_VARS'] + " CONFIG+=debug CONFIG-=release"
					end
					puts ENV['QTDIR']
					Jake.run3('./build', extpath, {}, true)
				end
			end

			ext_dir = File.join($startdir, 'platform/linux/bin/extensions')
			mkdir_p ext_dir if not File.exist? ext_dir
			File.open(File.join(ext_dir, 'extensions.pri'), "wb") do |fextensions|
				fextensions.puts "SOURCES += ../../ruby/ext/rho/extensions.c"
				fextensions.puts extensions_lib
			end
		end


		task :after_bundled do
			linux_rhopath = $tmpdir + '/rho'
			mkdir_p linux_rhopath
			namepath = File.join(linux_rhopath,"name.txt")
			old_appname = File.read(namepath) if File.exist?(namepath)

			confpath = File.join(linux_rhopath,"apps/rhoconfig.txt.changes")
			confpath_content = File.read(confpath) if File.exist?(confpath)

			linux_rhopath = linux_rhopath + '/'
			rm_rf linux_rhopath + 'lib'
			rm_rf linux_rhopath + 'apps'
			rm_rf linux_rhopath + 'db' if old_appname != $appname

			cp_r $srcdir + '/lib', linux_rhopath
			cp_r $srcdir + '/apps', linux_rhopath
			cp_r $srcdir + '/db', linux_rhopath

			File.open(namepath, "w") { |f| f.write($appname) }
			File.open(confpath, "w") { |f| f.write(confpath_content) }  if old_appname == $appname && confpath_content && confpath_content.length()>0
		end
	end

	task :linux => ["build:linux:rhobundle", "config:linux:application"] do
		puts "Starting to build linux application in " + $qt_project_dir
		chdir $config["build"]["linuxpath"]

		ENV['RHO_QMAKE_SPEC'] = $qmake_makespec
		ENV['RHO_VSCMNTOOLS'] = $vscommontools


		target_app_name = File.join($target_path, $appname)
		if !File.exist?(target_app_name)
			if $qmake_addition_args != nil and $qmake_addition_args != ''
				Jake.run3('"$QTDIR/bin/qmake" -o Makefile -r -spec $RHO_QMAKE_SPEC "CONFIG-=debug" "CONFIG+=release" ' +
					$qmake_addition_args + ' RhoSimulator.pro', $qt_project_dir)
			else
				Jake.run3('"$QTDIR/bin/qmake" -o Makefile -r -spec $RHO_QMAKE_SPEC "CONFIG-=debug" "CONFIG+=release" RhoSimulator.pro',
					$qt_project_dir)
			end
			Jake.run3('make clean', $qt_project_dir)
			Jake.run3('make all', $qt_project_dir)
			puts "Copying to dir" + $target_path

			if not File.directory?($target_path)
				FileUtils.mkdir_p($target_path)
			end

			cp File.join($startdir, "platform/linux/bin/RhoSimulator/RhoSimulator"), target_app_name
		end
		rho_path = File.join($target_path, "rho")
		rm_rf rho_path if File.exist?(rho_path)
		cp_r File.join($app_path, "bin/RhoBundle"), rho_path

		chdir $startdir
	end

end

namespace "device" do
	namespace "linux" do
		namespace "production" do
			def createFolders()
				opt_path = File.join($target_path, "opt", "#{$appname}")

				if not File.directory?(opt_path)
					FileUtils.mkdir_p opt_path
				end

				icon = File.join($app_path, "icon/icon.ico")
				if !File.exist? icon
					icon = File.join($startdir, "platform" , "wm", "rhodes", "resources", "icon.ico")
				end

				cp icon, opt_path
				FileUtils.mv(File.join($target_path, "rho"), opt_path, :verbose => true, :force => true)
				FileUtils.chmod_R(0777, File.join(opt_path, "rho"))
				FileUtils.mv(File.join($target_path, $appname), opt_path, :verbose => true, :force => true)

				desktop_path = File.join($target_path, "usr", "share", "applications")
				if not File.directory?(desktop_path)
					FileUtils.mkdir_p desktop_path
				end

				File.open(File.join(desktop_path, "#{$appname}.desktop"), 'w') { |file|
					file.write("[Desktop Entry]\n")
					file.write("Type=Application\n")
					file.write("Version=#{$version_app}\n")
					file.write("Name=#{$appname}\n")
					file.write("GenericName=\"Web Browser\"\n")
					file.write("Exec=/opt/#{$appname}/#{$appname}\n")
					file.write("Icon=/opt/#{$appname}/icon.ico\n")
				}
			end

			def addDepLibs()
				ldd_out = Jake.run("ldd", [File.join($target_path, $appname)])
				app_libs = File.join($target_path, "opt", "#{$appname}", "app_libs")
				if not File.directory?(app_libs)
				  FileUtils.mkdir_p app_libs
				end

				depsarray = ldd_out.scan( /(\/[\/\.\w\-\+]*\.so[\.\d]*)/)
				depsarray.uniq.each{
				  |dep| appdep = dep[0]

				  target_dep_name = appdep.scan(/\/(libQ[\.\w\-\+]*\.so[\.\d]*)/)
				  target_dep_name.uniq.each{
				    |deplibname|
				    cp appdep, File.join(app_libs, deplibname[0])
				    puts "Adding lib #{appdep}"
				  }
				}
			end

			task :deb => ["build:linux"] do
				createFolders()

				control_template = File.read File.join( $startdir, "platform", "linux", "tasks", "control.erb")
				erb = ERB.new control_template

				debian_dir = File.join($target_path, "DEBIAN")
				if not File.directory?(debian_dir)
					FileUtils.mkdir_p debian_dir
				end
				File.open(File.join(debian_dir, "control"), 'w' ) { |f| f.write erb.result binding }

				Jake.run3('fakeroot dpkg-deb --build linux', File.join($app_path, "bin", "target"))
				rm_rf $target_path
				FileUtils.mkdir_p $target_path
				FileUtils.mv(File.join($app_path, "bin", "target", "linux.deb"), File.join($target_path, "#{$appname}_#{$version_app}_amd64.deb"))
			end

			task :rpm => ["build:linux"] do
				createFolders()
				target_folder = File.join($app_path, "bin", "target")
				$linuxroot = File.join(target_folder, "linux")
				$buildroot = File.join($linuxroot, "rpmbuildroot")


				$bin_file = "linux.tar"
				$bin_archive = File.join(target_folder, $bin_file)

				rm $bin_archive if File.exist? $bin_archive
				FileUtils.mv($linuxroot, File.join(target_folder, "#{$appname}-#{$version_app}"))
				Jake.run3("tar -cvf #{$bin_file} #{$appname}-#{$version_app}", target_folder)
				FileUtils.rm_r File.join(target_folder, "#{$appname}-#{$version_app}") if File.exist? File.join(target_folder, "#{$appname}-#{$version_app}")

				FileUtils.mkdir_p $buildroot
				FileUtils.mkdir_p File.join($buildroot, "SOURCES")
				FileUtils.mkdir_p File.join($buildroot, "BUILD")
			    FileUtils.mkdir_p File.join($buildroot, "BUILDROOT")
				FileUtils.mkdir_p File.join($buildroot, "RPMS")
				FileUtils.mkdir_p File.join($buildroot, "SPECS")
				FileUtils.mkdir_p File.join($buildroot, "SRPMS")

				FileUtils.mv($bin_archive, File.join($buildroot, "SOURCES", "#{$appname}.tar"))
				$bin_archive = File.join($buildroot, "SOURCES", "#{$appname}.tar")

				control_template = File.read File.join( $startdir, "platform", "linux", "tasks", "rpm_spec.erb")
				erb = ERB.new control_template
				File.open(File.join($buildroot, "rpm.spec"), 'w' ) { |f| f.write erb.result binding }

                lint_exceptions_template = File.read File.join( $startdir, "platform", "linux", "tasks", "linter_exceptions.erb")
				erb = ERB.new lint_exceptions_template
				File.open(File.join($buildroot, "SOURCES", "#{$appname}.rpmlintrc"), 'w' ) { |f| f.write erb.result binding }


				puts Jake.run3("rpmbuild --define \"_topdir #{$buildroot}\" --define '_build_id_links none' --define 'debug_package %{nil}' -bb rpm.spec", $buildroot)

				Dir.glob(File.join($buildroot, "**", "*.rpm")).each do | filename |
					FileUtils.mv(filename, File.join($linuxroot, File.basename(filename)))
					puts filename
				end
				FileUtils.rm_r $buildroot

			end
		end

		task :production => ["config:sys_recognize", "clean:linux"] do
            $linter_exceptions = []
            $additional_args = ""
			if $ubuntu
				$deps = "qt5-default, libqt5webengine5, libqt5webenginecore5, libqt5webenginewidgets5, libqt5multimedia5"
				Rake::Task['device:linux:production:deb'].invoke
			elsif $astra
				$deps = "libqt5widgets5, libqt5gui5, libqt5network5, libqt5webengine5, libqt5webenginecore5, libqt5webenginewidgets5, libqt5multimedia5"
				Rake::Task['device:linux:production:deb'].invoke
			elsif $altlinux
				$create_buildroot = true
				$deps = ["libqt5-qml", "libqt5-quickwidgets", "libqt5-webenginecore", "libqt5-webengine", "libqt5-core", "libqt5-gui",
				"libqt5-network", "libqt5-multimedia", "libgmp", "libstdc++"]
				Rake::Task['device:linux:production:rpm'].invoke
			elsif $redos
				$deps = ["qt5", "qt5-qtbase", "qt5-qtbase-common", "qt5-qtbase-gui", "qt5-qtwebengine",
				"qt5-qtmultimedia", "qt5-qtwebchannel", "gmp", "libstdc++"]
				Rake::Task['device:linux:production:rpm'].invoke
			elsif $rosalinux
				#$create_buildroot = true
				$architecture = "noarch"
                #$additional_args = "%global _nonzero_exit_pkgcheck_terminate_build 0"
                $linter_exceptions = ["W: no-binary", "E: arch-independent-package-contains-binary-or-object", "E: dir-or-file-in-opt", "E: non-standard-dir-perm", "W: desktopfile-without-binary", "W: dir-or-file-in-opt", "E: non-standard-executable-perm", "E: explicit-lib-dependency", "W: no-documentation", "E: invalid-desktopfile", "W: script-without-shebang", "E: non-standard-group", "W: no-url-tag","E: world-writable", "E: wrong-script-end-of-line-encoding"]
				$deps = ["lib64qt5webenginecore5", "lib64qt5webenginewidgets5" , "lib64qt5webengine5" , "lib64qt5multimedia5", "lib64qt5gui5", "lib64gmp10"]
				Rake::Task['device:linux:production:rpm'].invoke
			else
				puts "Fail! The current system has not been recognized whild production."
				exit 1
			end
			puts "Finished"
		end
	end
end

namespace "run" do
	task :linux => ["build:linux"] do
		Jake.run3(File.join($target_path, $appname) + ' --remote-debugging-port=9090')
	end

	namespace "linux" do
		task :spec do
			Jake.decorate_spec do
			  	#Rake::Task['config:linux'].invoke
			    Rake::Task['build:linux'].invoke

			    linuxrhopath = File.join($target_path, 'rho')

			    dbpath = File.join(linuxrhopath, 'db')
			  	rm_rf dbpath if File.exist?(dbpath)

			    linuxlogpath = File.join(linuxrhopath,"rholog.txt")
			    linuxlogpospath = File.join(linuxrhopath, "rholog.txt_pos")
			    linuxconfigpath = File.join(linuxrhopath, "apps", "rhoconfig.txt.changes")
			    rm_rf linuxlogpath if File.exist?(linuxlogpath)
			    rm_rf linuxlogpospath if File.exist?(linuxlogpospath)
			    rm_rf linuxconfigpath if File.exist?(linuxconfigpath)

			    Jake.before_run_spec
			    start = Time.now
			    args = [' ']

			    targetFile = File.join("..", $appname)
			    start = Time.now
			    counter = 0
			    Jake.run2(targetFile, args, {:directory => linuxrhopath, :nowait => false}) do |line|
			      counter += 1
			    end
			    counter = 0
			    sleep(5)

			    current_spec_name = ''
			    failed_specs = []
			    File.open(linuxlogpath, 'r:UTF-8').each do |line|
			      counter += 1
			      Jake.process_spec_output(line)
			      currentSpecArray = line.scan( /.*\[([\w\\\/\_]{5,})\].*/)
			      currentSpecArray.uniq.each{
				    |specname| current_spec_name = specname
				  }

				  failCheckArray = line.scan(/^.*(FAIL:).*[^(RHO: not supported)]$/)
				  if (failCheckArray.length > 0)
				  	failed_specs += current_spec_name
				  	puts "Fail on line #{counter}"
				  end
			    end

			    puts failed_specs.uniq

			    puts "Checked lines: " + counter.to_s
			    Jake.process_spec_results(start)

			    $stdout.flush
			    chdir $startdir

			    if ($failed > 0)
			      puts "Specs failed with " + $failed.to_s + " failes"
			      exit 1
			    end
			end
	    end
	end

end

namespace "clean" do
	namespace "linux" do
		task :rhosimulator do
			rhoSimDir = File.join( $startdir, "platform/linux/RhoSimulator" )
			FileUtils.rm_rf("#{rhoSimDir}/.", secure: true)
		end
	end

	task :linux => ["config:linux", "clean:common"]do
		rm_rf $tmpdir
		rm_rf File.join($startdir, 'platform/shared/qt/rhodes/GeneratedFiles')
		rm_rf File.join($startdir, 'platform/linux/bin')

		#common_target_path = File.join($app_path, "bin")
		#rm_rf common_target_path if File.exist? common_target_path

		rm_rf File.join($app_path, "bin", "tmp") if File.exist? File.join($app_path, "bin", "tmp")
		rm_rf File.join($app_path, "bin", "RhoBundle") if File.exist? File.join($app_path, "bin", "RhoBundle")
        rm_rf File.join($app_path, "bin", "target") if File.exist? File.join($app_path, "bin", "target")
	end
end

# --- ALT Linux (GTK) build tasks (MVP) ---

namespace "config" do
  # Minimal config for altLinux GTK build (no Qt)
  task :altLinux => ["switch_app"] do
    $current_platform = "linux"

    $bindir = File.join($app_path, 'bin')
    $srcdir = File.join($bindir, 'RhoBundle')
    $tmpdir = File.join($bindir, 'tmp')
    $excludelib = ['**/builtinME.rb', '**/ServeME.rb', '**/dateME.rb', '**/rationalME.rb']

    $appname = $app_config["name"].nil? ? "Rhodes" : $app_config["name"]
    $appname = $appname.gsub(/[^0-9a-zA-Z\-\+\.]/,'')
    $vendor = $app_config['vendor']
    $vendor = "Tau Technologies" if $vendor.nil?
    $log_file = $app_config["applog"].nil? ? "applog.txt" : $app_config["applog"]

    $buildcfg = $app_config["buildcfg"] unless $buildcfg
    $buildcfg = "Release" unless $buildcfg

    $detoolappflag = $js_application == true ? "js" : "ruby"

    $homedir = `echo ~`.to_s.strip

    Rake::Task["config:common"].invoke

    if !$app_config["version"].nil?
      $version_app = $app_config["version"]
    else
      $version_app = "1.0"
    end

    # Use a separate target dir for altlinux (may be skipped when altMobile overrides)
    $target_path = File.join($app_path, "bin", "target", "altlinux")
    unless defined?($altgtk_skip_altlinux_target_creation) && $altgtk_skip_altlinux_target_creation
      mkdir_p $target_path
    end

    # Detect architecture for RPM metadata
    $architecture = Jake.run("uname", ["-m"]).strip

    altgtk_regenerate_metadata

    $rubypath = 'res/build-tools/rubylinux'
  end
end

namespace "build" do
  namespace "altLinux" do
    # Build only the application bundle, without extensions
    task :rhobundle => ["config:altLinux", "build:bundle:noxruby"] do
      Jake.build_file_map(File.join($srcdir, "apps"), "rhofilelist.txt")
    end

    # Build minimal GTK4/libadwaita runner (no WebKit for MVP)
    task :runner => ["config:altLinux"] do
      runner_dir = File.join($startdir, 'platform', 'altMobile', 'gtk')
      mkdir_p runner_dir
      Jake.run3('make clean', runner_dir)
      altgtk_ensure_core_libs
      # Pass OUTDIR and APPNAME to Makefile
      env = {
        'OUTDIR' => $target_path,
        'APPNAME' => $appname
      }
      rho_libs = altgtk_core_lib_paths
      if rho_libs.all? { |p| File.exist?(p) }
        env['ENABLE_CORE'] = '1'
        env['RHO_ROOT'] = $startdir
      end
      Jake.run3('make', runner_dir, env)
    end

    # Aggregate: build bundle and runner, then install bundle to target
    task :all => [:rhobundle, :runner] do
      rho_path = File.join($target_path, 'rho')
      rm_rf rho_path if File.exist?(rho_path)
      cp_r File.join($app_path, 'bin', 'RhoBundle'), rho_path
    end
  end
end

namespace "device" do
  namespace "altLinux" do
    namespace "production" do
      # Create AltLinux filesystem layout under $target_path
      def createFolders_altlinux()
        opt_path = File.join($target_path, "opt", "#{$appname}")
        FileUtils.mkdir_p opt_path unless File.directory?(opt_path)

        icon = File.join($app_path, "icon/icon.ico")
        icon = File.join($startdir, "platform" , "wm", "rhodes", "resources", "icon.ico") unless File.exist?(icon)
        cp icon, opt_path

        rho_src = File.join($target_path, 'rho')
        FileUtils.mv(rho_src, opt_path, :verbose => true, :force => true) if File.exist?(rho_src)
        FileUtils.chmod_R(0777, File.join(opt_path, "rho")) if File.exist?(File.join(opt_path, "rho"))

        bin_src = File.join($target_path, $appname)
        FileUtils.mv(bin_src, opt_path, :verbose => true, :force => true) if File.exist?(bin_src)

        desktop_path = File.join($target_path, "usr", "share", "applications")
        FileUtils.mkdir_p desktop_path unless File.directory?(desktop_path)
        File.open(File.join(desktop_path, "#{$appname}.desktop"), 'w') do |file|
          file.write("[Desktop Entry]\n")
          file.write("Type=Application\n")
          file.write("Version=#{$version_app}\n")
          file.write("Name=#{$appname}\n")
          file.write("GenericName=\"Web Browser\"\n")
          file.write("Exec=/opt/#{$appname}/#{$appname}\n")
          file.write("Icon=/opt/#{$appname}/icon.ico\n")
        end
      end

      task :rpm => ["build:altLinux:all"] do
        createFolders_altlinux()

        target_folder = File.join($app_path, "bin", "target")
        $linuxroot = File.join(target_folder, "altlinux")
        $buildroot = File.join($linuxroot, "rpmbuildroot")

        $bin_file = "altlinux.tar"
        $bin_archive = File.join(target_folder, $bin_file)

        rm $bin_archive if File.exist? $bin_archive
        FileUtils.mv($linuxroot, File.join(target_folder, "#{$appname}-#{$version_app}"))
        Jake.run3("tar -cvf #{$bin_file} #{$appname}-#{$version_app}", target_folder)
        FileUtils.rm_r File.join(target_folder, "#{$appname}-#{$version_app}") if File.exist? File.join(target_folder, "#{$appname}-#{$version_app}")

        FileUtils.mkdir_p $buildroot
        FileUtils.mkdir_p File.join($buildroot, "SOURCES")
        FileUtils.mkdir_p File.join($buildroot, "BUILD")
        FileUtils.mkdir_p File.join($buildroot, "BUILDROOT")
        FileUtils.mkdir_p File.join($buildroot, "RPMS")
        FileUtils.mkdir_p File.join($buildroot, "SPECS")
        FileUtils.mkdir_p File.join($buildroot, "SRPMS")

        FileUtils.mv($bin_archive, File.join($buildroot, "SOURCES", "#{$appname}.tar"))
        $bin_archive = File.join($buildroot, "SOURCES", "#{$appname}.tar")

        # Set RPM metadata
        $create_buildroot = true
        $additional_args = ""
        # Map common arch names
        $architecture = "x86_64" if $architecture.nil? || $architecture.strip.empty?
        altgtk_resolve_runtime_deps

        control_template = File.read File.join($startdir, "platform", "linux", "tasks", "rpm_spec.erb")
        erb = ERB.new control_template
        File.open(File.join($buildroot, "rpm.spec"), 'w' ) { |f| f.write erb.result binding }

        puts Jake.run3("rpmbuild --define \"_topdir #{$buildroot}\" --define '_build_id_links none' --define 'debug_package %{nil}' -bb rpm.spec", $buildroot)

        Dir.glob(File.join($buildroot, "**", "*.rpm")).each do | filename |
          FileUtils.mv(filename, File.join($linuxroot, File.basename(filename)))
          puts filename
        end
        FileUtils.rm_r $buildroot
      end
    end

    task :production => ["clean:altLinux:minimal"] do
      Rake::Task['device:altLinux:production:rpm'].invoke
      puts "Finished"
    end
  end
end

namespace "clean" do
  namespace "altLinux" do
    # Minimal clean without invoking Qt-dependent config:linux
    task :minimal => ["config:altLinux"] do
      # remove tmp and previous targets for altlinux only
      begin
        rm_rf $tmpdir if $tmpdir && File.exist?($tmpdir)
      rescue
      end
      alt_target = File.join($app_path, 'bin', 'target', 'altlinux')
      rm_rf alt_target if File.exist?(alt_target)
      # cleanup previous bundle (safe)
      rb = File.join($app_path, 'bin', 'RhoBundle')
      rm_rf rb if File.exist?(rb)
      ALTGTK_CORE_LIB_TARGETS.each do |folder, _|
        core_dir = File.join($startdir, 'platform', 'linux', 'bin', folder)
        rm_rf core_dir if File.exist?(core_dir)
      end
    end
  end
end

namespace "clean" do
  namespace "altMobile" do
    # Minimal clean for altMobile (no Qt)
    task :minimal => ["config:altMobile"] do
      begin
        rm_rf $tmpdir if $tmpdir && File.exist?($tmpdir)
      rescue
      end
      alt_target = File.join($app_path, 'bin', 'target', 'altMobile')
      rm_rf alt_target if File.exist?(alt_target)
      rb = File.join($app_path, 'bin', 'RhoBundle')
      rm_rf rb if File.exist?(rb)
      ALTGTK_CORE_LIB_TARGETS.each do |folder, _|
        core_dir = File.join($startdir, 'platform', 'linux', 'bin', folder)
        rm_rf core_dir if File.exist?(core_dir)
      end
    end
  end
end

namespace "config" do
  # Internal helper toggled before invoking altLinux config from altMobile
  task :altMobile_preset do
    $altgtk_skip_altlinux_target_creation = true
  end

  # Configure altMobile (reuse altLinux base, override target path)
  task :altMobile => [:altMobile_preset, "config:altLinux"] do
    $altgtk_skip_altlinux_target_creation = false
    $target_path = File.join($app_path, "bin", "target", "altMobile")
    mkdir_p $target_path

    altmobile_cfg = $app_config['altMobile'] if $app_config
    linux_cfg = $app_config['linux'] if $app_config

    merged_exts = []
    if linux_cfg.is_a?(Hash) && linux_cfg['extensions'].respond_to?(:each)
      merged_exts.concat(Array(linux_cfg['extensions']))
    end
    if altmobile_cfg.is_a?(Hash) && altmobile_cfg['extensions'].respond_to?(:each)
      merged_exts.concat(Array(altmobile_cfg['extensions']))
    end

    unless merged_exts.empty?
      $app_config['extensions'] = [] unless $app_config['extensions'].is_a?(Array)
      $app_config['extensions'] |= merged_exts
    end
    abi = nil
    if altmobile_cfg.is_a?(Hash)
      abis = altmobile_cfg['abis']
      abi = abis.first if abis.respond_to?(:first) && !abis.is_a?(String)
      abi = abis if abi.nil?
    end
    abi = abi.to_s.downcase
    $rubypath = 'res/build-tools/rubylinux'
    $rubypath = 'res/build-tools/rubylinux_aarch64' if abi == 'arm'
  end
end

namespace "build" do
  namespace "altMobile" do
    task :rhobundle => ["config:altMobile", "build:bundle:noxruby"] do
      Jake.build_file_map(File.join($srcdir, "apps"), "rhofilelist.txt")
    end
    task :runner => ["config:altMobile"] do
      runner_dir = File.join($startdir, 'platform', 'altMobile', 'gtk')
      mkdir_p runner_dir
      Jake.run3('make clean', runner_dir)
      altgtk_ensure_core_libs
      env = { 'OUTDIR' => $target_path, 'APPNAME' => $appname }
      extra_libs = []
      if altgtk_requested_extensions.include?('rhoconnect-client')
        extra_libs << '-lrhoconnect-client'
      end
      env['EXTRA_LIBS'] = extra_libs.join(' ') unless extra_libs.empty?
      # Enable core integration if static libs exist
      if altgtk_core_lib_paths.all? { |p| File.exist?(p) }
        env['ENABLE_CORE'] = '1'
        env['RHO_ROOT'] = $startdir
      end
      Jake.run3('make', runner_dir, env)
    end
    # Build Rhodes static libraries via qmake (rubylib, rholib, sqlite3, syncengine, curl)
    task :rhodeslibs => ["config:qt"] do
      qt_dir = File.join($startdir, 'platform', 'shared', 'qt')
      # Ensure makespec is set; default to linux-g++ if not provided
      spec = $qmake_makespec || 'linux-g++'
      ENV['RHO_QMAKE_SPEC'] = spec
      if $qmake_addition_args != nil and $qmake_addition_args != ''
        Jake.run3('"$QTDIR/bin/qmake" -o Makefile -r -spec $RHO_QMAKE_SPEC "CONFIG-=debug" "CONFIG+=release" ' + $qmake_addition_args + ' RhoSimulator.pro', qt_dir)
      else
        Jake.run3('"$QTDIR/bin/qmake" -o Makefile -r -spec $RHO_QMAKE_SPEC "CONFIG-=debug" "CONFIG+=release" RhoSimulator.pro', qt_dir)
      end
      Jake.run3('make sub-rubylib-all sub-rholib-all sub-sqlite3-all sub-syncengine-all sub-curl-all', qt_dir)

      coreapi_dir = File.join($startdir, 'lib', 'commonAPI', 'coreapi', 'ext', 'platform', 'qt')
      Jake.run3('make clean', coreapi_dir) if File.exist?(File.join(coreapi_dir, 'Makefile'))
      if $qmake_addition_args != nil and $qmake_addition_args != ''
        Jake.run3('"$QTDIR/bin/qmake" -o Makefile -r -spec $RHO_QMAKE_SPEC "CONFIG-=debug" "CONFIG+=release" ' + $qmake_addition_args + ' coreapi.pro', coreapi_dir)
      else
        Jake.run3('"$QTDIR/bin/qmake" -o Makefile -r -spec $RHO_QMAKE_SPEC "CONFIG-=debug" "CONFIG+=release" coreapi.pro', coreapi_dir)
      end
      Jake.run3('make', coreapi_dir)

      if altgtk_requested_extensions.include?('rhoconnect-client')
        rhoc_root = $app_extensions_list && $app_extensions_list['rhoconnect-client']
        rhoc_path = rhoc_root && File.join(rhoc_root, 'ext')
        if rhoc_path && File.directory?(rhoc_path) && File.exist?(File.join(rhoc_path, 'build'))
          ENV['RHO_PLATFORM'] = 'linux'
          ENV['RHO_BUILD_CONFIG'] = $buildcfg
          ENV['PWD'] = $startdir
          ENV['RHO_ROOT'] = $startdir
          ENV['TARGET_TEMP_DIR'] = File.join($startdir, 'platform', 'linux', 'bin', 'extensions')
          ENV['TEMP_FILES_DIR'] = File.join(ENV['TARGET_TEMP_DIR'], 'rhoconnect-client')
          ENV['RHO_VSPROJ_SDK_PLATFORM'] = $sdk if defined?($sdk)
          qmake_path = defined?($qmake) && $qmake ? $qmake : nil
          qmake_path ||= (ENV['QTDIR'] ? File.join(ENV['QTDIR'], 'bin', 'qmake') : nil)
          ENV['RHO_QMAKE'] = qmake_path if qmake_path
          qmake_vars = []
          qmake_vars << 'RHOSIMULATOR_BUILD=1' if $rhosimulator_build
          qmake_vars << $qmake_addition_args if $qmake_addition_args && !$qmake_addition_args.empty?
          ENV['RHO_QMAKE_VARS'] = qmake_vars.join(' ').strip
          ENV['RHO_QMAKE_SPEC'] = spec
          ENV['RHO_VSCMNTOOLS'] = $vscommontools if defined?($vscommontools)
          Jake.run3('./build', rhoc_path, {}, true)
        else
          puts "Warning: rhoconnect-client extension path not resolved; skipping native extension build."
        end
      end
    end
    task :all => [:rhobundle, :runner] do
      rho_path = File.join($target_path, 'rho')
      rm_rf rho_path if File.exist?(rho_path)
      cp_r File.join($app_path, 'bin', 'RhoBundle'), rho_path
    end
    # requested entrypoint name
    task :production do
      Rake::Task['device:altMobile:production'].invoke
    end
  end
end

namespace "device" do
  namespace "altMobile" do
    namespace "production" do
      task :rpm => ["build:altMobile:all"] do
        createFolders_altlinux()

        target_folder = File.join($app_path, "bin", "target")
        $linuxroot = File.join(target_folder, "altMobile")
        $buildroot = File.join($linuxroot, "rpmbuildroot")

        $bin_file = "altmobile.tar"
        $bin_archive = File.join(target_folder, $bin_file)

        rm $bin_archive if File.exist? $bin_archive
        FileUtils.mv($linuxroot, File.join(target_folder, "#{$appname}-#{$version_app}"))
        Jake.run3("tar -cvf #{$bin_file} #{$appname}-#{$version_app}", target_folder)
        FileUtils.rm_r File.join(target_folder, "#{$appname}-#{$version_app}") if File.exist? File.join(target_folder, "#{$appname}-#{$version_app}")

        FileUtils.mkdir_p $buildroot
        FileUtils.mkdir_p File.join($buildroot, "SOURCES")
        FileUtils.mkdir_p File.join($buildroot, "BUILD")
        FileUtils.mkdir_p File.join($buildroot, "BUILDROOT")
        FileUtils.mkdir_p File.join($buildroot, "RPMS")
        FileUtils.mkdir_p File.join($buildroot, "SPECS")
        FileUtils.mkdir_p File.join($buildroot, "SRPMS")

        FileUtils.mv($bin_archive, File.join($buildroot, "SOURCES", "#{$appname}.tar"))
        $bin_archive = File.join($buildroot, "SOURCES", "#{$appname}.tar")

        $create_buildroot = true
        $additional_args = ""
        $architecture = "x86_64" if $architecture.nil? || $architecture.strip.empty?
        altgtk_resolve_runtime_deps

        control_template = File.read File.join($startdir, "platform", "linux", "tasks", "rpm_spec.erb")
        erb = ERB.new control_template
        File.open(File.join($buildroot, "rpm.spec"), 'w' ) { |f| f.write erb.result binding }

        puts Jake.run3("rpmbuild --define \"_topdir #{$buildroot}\" --define '_build_id_links none' --define 'debug_package %{nil}' -bb rpm.spec", $buildroot)

        Dir.glob(File.join($buildroot, "**", "*.rpm")).each do | filename |
          FileUtils.mv(filename, File.join($linuxroot, File.basename(filename)))
          puts filename
        end
        FileUtils.rm_r $buildroot
      end
    end
    task :production => ["clean:altMobile:minimal"] do
      Rake::Task['device:altMobile:production:rpm'].invoke
      puts "Finished"
    end
  end
end
