package com.rhomobile.rhodes.util;

import android.bluetooth.BluetoothAdapter;
import android.content.Context;
import android.provider.Settings.Secure;
import android.telephony.TelephonyManager;

import java.lang.reflect.Method;
import java.util.UUID;

//import com.rhomobile.rhodes.RhoConf;
import com.rhomobile.rhodes.Capabilities;
import com.rhomobile.rhodes.Logger;

/**
 * The UUID is generated by using ANDROID_ID as the base key if appropriate, falling back on
 * TelephonyManager.getDeviceID() if ANDROID_ID is known to be incorrect, and finally falling back
 * on a random UUID that's persisted to SharedPreferences if getDeviceID() does not return a
 * usable value.
 *
 * In some rare circumstances, this ID may change.  In particular, if the device is factory reset a new device ID
 * may be generated.  In addition, if a user upgrades their phone from certain buggy implementations of Android 2.2
 * to a newer, non-buggy version of Android, the device ID may change.  Or, if a user uninstalls your app on
 * a device that has neither a proper Android ID nor a Device ID, this ID may change on reinstallation.
 *
 * Note that if the code falls back on using TelephonyManager.getDeviceId(), the resulting ID will NOT
 * change after a factory reset.  Something to be aware of.
 *
 * Works around a bug in Android 2.2 for many devices when using ANDROID_ID directly.
 *
 * @see http://code.google.com/p/android/issues/detail?id=10603
 *
 */
public class PhoneId
{
    private static final String TAG = PhoneId.class.getSimpleName();
    //    private static final String CONF_PHONE_ID = "phone_id";
    private String mPhoneId;

    private PhoneId(String phoneId) {
        mPhoneId = phoneId;
    }

    private PhoneId(Context context) throws UnsupportedOperationException {
        String rawId = new String();
        final String androidId = Secure.getString(context.getContentResolver(), Secure.ANDROID_ID);

        // Use the Android ID unless it's broken, in which case fallback on deviceId,
        // unless it's not available, then fallback on a random number.
        if (!"9774d56d682e549c".equals(androidId)) {
            rawId += androidId;
            Logger.D(TAG, "ANDROID_ID: " + androidId);
        }
        if (Capabilities.PHONE_ENABLED) {
            final String deviceId = ((TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE)).getDeviceId();
            if (deviceId != null && deviceId.length() > 0) {
                rawId += deviceId;
                Logger.D(TAG, "Phone device id: " + deviceId);
            }
        }
        if (Capabilities.BLUETOOTH_ENABLED) {
            BluetoothAdapter bluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
            if (bluetoothAdapter != null) {
                final String bluetoothAddr = bluetoothAdapter.getAddress();
                if(bluetoothAddr != null && bluetoothAddr.length() > 0) {
                    rawId += bluetoothAddr;
                    Logger.D(TAG, "Bluetooth address: " + bluetoothAddr);
                }
            }
        }
        try {
            Class<?> c = Class.forName("android.os.SystemProperties");
            Method get = c.getMethod("get", String.class);
            final String serialNo = (String) get.invoke(c, "ro.serialno");
            rawId += serialNo;
            Logger.D(TAG, "Serial#: " + serialNo);
        } catch (Exception ignored) {
        }
        if (rawId.length() > 0) {
            UUID uuid = UUID.nameUUIDFromBytes(rawId.getBytes());
            mPhoneId = uuid.toString();
            Logger.D(TAG, "Generated phone id: " + mPhoneId);
        } else {
            throw new UnsupportedOperationException("Cannot generate unique device id.");
        }
    }

    public String getString() {
        return mPhoneId;
    }

    @Override
    public String toString()
    {
        return getString();
    }

    public static PhoneId getId(Context ctx, String id) {
        return (id != null && id.length() > 0) ? new PhoneId(id) : new PhoneId(ctx);
    }
}
